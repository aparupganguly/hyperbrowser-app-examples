import { ScrapedSource } from './scrape'
import { v4 as uuidv4 } from 'uuid'

export interface PostmanCollection {
  info: {
    name: string
    description: string
    schema: string
    _postman_id: string
  }
  item: Array<{
    name: string
    request: {
      method: string
      header: Array<{ key: string; value: string }>
      url: {
        raw: string
        protocol: string
        host: string[]
        path: string[]
        query?: Array<{ key: string; value: string }>
      }
    }
    response: any[]
  }>
}

export function buildPostmanCollection(
  sources: ScrapedSource[],
  query: string
): PostmanCollection {
  const collection: PostmanCollection = {
    info: {
      name: `SourceForge: ${query}`,
      description: `API endpoints discovered while researching: ${query}\n\nGenerated by OpenAI SourceForge using Hyperbrowser`,
      schema: 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json',
      _postman_id: uuidv4()
    },
    item: []
  }

  sources.forEach((source, sourceIndex) => {
    if (source.endpoints.length === 0) return

    // Create a folder for each source
    const sourceFolder = {
      name: `${source.title} (${source.endpoints.length} endpoints)`,
      item: source.endpoints.map((endpoint, endpointIndex) => {
        const url = new URL(endpoint.url)
        const pathSegments = url.pathname.split('/').filter(segment => segment.length > 0)
        
        // Extract query parameters
        const queryParams = Array.from(url.searchParams.entries()).map(([key, value]) => ({
          key,
          value
        }))

        // Build headers from endpoint headers
        const headers = Object.entries(endpoint.headers || {}).map(([key, value]) => ({
          key,
          value: String(value)
        }))

        return {
          name: `${endpoint.method} ${url.pathname || '/'}`,
          request: {
            method: endpoint.method,
            header: headers,
            url: {
              raw: endpoint.url,
              protocol: url.protocol.replace(':', ''),
              host: url.hostname.split('.'),
              path: pathSegments,
              ...(queryParams.length > 0 && { query: queryParams })
            },
            ...(endpoint.payload && {
              body: {
                mode: 'raw',
                raw: JSON.stringify(endpoint.payload, null, 2),
                options: {
                  raw: {
                    language: 'json'
                  }
                }
              }
            })
          },
          response: []
        }
      })
    }

    collection.item.push(sourceFolder as any)
  })

  return collection
}

export function buildEndpointManifest(sources: ScrapedSource[], query: string) {
  const manifest = {
    query,
    generatedAt: new Date().toISOString(),
    totalSources: sources.length,
    totalEndpoints: sources.reduce((sum, source) => sum + source.endpoints.length, 0),
    sources: sources.map(source => ({
      url: source.url,
      title: source.title,
      endpointCount: source.endpoints.length,
      endpoints: source.endpoints.map(endpoint => ({
        method: endpoint.method,
        url: endpoint.url,
        status: endpoint.status,
        headers: endpoint.headers,
        hasPayload: !!endpoint.payload
      }))
    })),
    usage: {
      description: 'Use these endpoints for further API exploration and development',
      postmanImport: 'Import the accompanying Postman collection for testing',
      notes: [
        'Endpoints were captured during live browser sessions',
        'Some endpoints may require authentication',
        'Headers and payloads are preserved from actual requests',
        'Status codes reflect actual responses during capture'
      ]
    }
  }

  return manifest
} 